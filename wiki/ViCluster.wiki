#summary ViCluster test framework for simulating cluster using single JVM

= Introduction =
`ViCluster` is evolution of TestUtils. It provides an alternative to direct use of Isolate class and few additional enhancements.

`ViCluster` was originally developed for writing automated test of Coherence based application. Key challenge for such testing is internal use of singletons in Coherence which make it impossible to have two independent nodes in same JVM. This limitation is worked around using multiple classloaders, each pseudo node (isolate) use own class loader (thus own singletons).

= Key features =
 * Starting all kind of nodes inside one JVM (member and extend client, storage enabled and disabled), supporting any type of Coherence topology.
 * Have independent system properties for each isolate.
 * Classpath of each isolate could be tweaked independently.
 * Output of isolates could be optionally prefixed by isolate name.
 * Isolate could be forcibly terminated.
 * Isolate can be suspended/resumes (server crash and long GC pauses could be simulated this way).
 * Test code can be executed in context of any JVM. 

= Examples =
Simple test cluster example
{{{
ViCluster cluster;

@After
public void dropCluster() {
	// It is not recommended to shutdown cluster after each test because
	// cluster startup takes few seconds.
	// Normally you would setup your application topology once and resuse it
	// in multiple tests
	if (cluster != null) {
		cluster.shutdown();
	}
}

@Test
public void test_simple_cluster() {
	// you should add to isolate package list
	// * Coherence (com.tangosol)
	// * GridKit (org.gridkit)
	// * Your application package
	// * Some libraries should also be included to work properly (e.g. mockito)
	cluster = new ViCluster("simple_cluster", "org.gridkit", "com.tangosol");
	
	// present for in-JVM cluster
	CohHelper.enableFastLocalCluster(cluster);
	// using default config in this case
	CohHelper.cacheConfig(cluster, "/coherence-cache-config.xml");

	// Creating server node
	ViNode storage = cluster.node("storage");
	CohHelper.localstorage(storage, true);
	
	// simulating DefaultCacheServer startup
	storage.start(DefaultCacheServer.class);
	
	ViNode client = cluster.node("client");
	CohHelper.localstorage(client, false);

	final String cacheName = "distr-a";
	
	// pure magic at this point
	// instance of callable will be serialized and deserialized with classloader of "client" node
	// and executed in context of client JVM
	// you can think of it a of remote call
	// return values or raised exceptions are converted to application classloader on way back
	client.exec(new Callable<Void>(){
		@Override
		public Void call() throws Exception {
			
			NamedCache cache = CacheFactory.getCache(cacheName);
			
			cache.put(0, 0);
			Assert.assertEquals(0, cache.get(0));
			
			return null;
		}
	});
}
}}}

`ViNode` interface allows you to exec any code in scope of isolate. Execution code in Isolate requires conversion to its classloader. This puts some limitation on that can be passed to `exec()` method.
`Runnable`/`Callable` object should be 
 * either `Serializable` static( or top level) class
 * or anonymous inner class.

In case of anonymous inner class it cannot access to fields of otter class (though final local variables are accessible as usual).

All objects referenced by instance passed to `exec()` should be serializable (serailization/deserialization is way to convert object to other classloader).

Examples
{{{
@Test
public void test_parameter_passing() {

	cluster = new ViCluster("test_parameter_passing", "org.gridkit");
	
	final double doubleV = 1.1d;
	
	cluster.node("node").exec(new Callable<Void>(){
		@Override
		public Void call() throws Exception {

			// final local variable from outer scope can be accessed as usual
			Assert.assertEquals(1.1d, doubleV, 0d);
			return null;
		}
	});

	final double[] doubleA = new double[]{1.1d};
	
	cluster.node("node").exec(new Callable<Void>(){
		@Override
		public Void call() throws Exception {
			
			Assert.assertEquals(1.1d, doubleA[0], 0d);
			
			// this will not be visible to caller, 
			// code inside of isolate is working with copy of array				
			doubleA[0] = 2.2d;
			return null;
		}
	});

	// array is outer scope there not changed
	Assert.assertEquals(1.1d, doubleA[0], 0d);
}	

void doSomething() {		
}

@Test(expected=NullPointerException.class)
public void test_outter_methods_unaccessible() {

	cluster = new ViCluster("test_parameter_passing", "org.gridkit");
	
	cluster.node("node").exec(new Callable<Void>(){
		@Override
		public Void call() throws Exception {
			
			// this will cause NPE
			// instance to outer class were not passed to isolate
			// this limitation is intentional
			doSomething();

			return null;
		}
	});
}	
}}}




= Source code and documentation =

Both jar-files, javadocs and source code are available via maven:

{{{
<dependency>
	<groupId>org.gridkit.coherence-tools</groupId>
	<artifactId>test-utils</artifactId>
	<version>0.1.8</version>
	<scope>test</scope>
</dependency>
}}}

Don't forget to add [MavenRepo GridKit Maven Repository] to your parent POM to get this dependency properly resolved.